#include <iostream>
#include <string>
using namespace std;

// 基类
class Base
{
public:
    int m_a = 100;

    void func()
    {
        cout << "Base成员函数已激活" << endl;
    }
}; // 添加右花括号

// 派生类
class son : public Base
{
public:
    int m_a = 200;

    void func()
    {
        cout << "son成员函数已激活" << endl;
    }
}; // 添加右花括号

// 测试函数 1
void test01()
{
    son s;
    cout << "son的m_a是：" << s.m_a << endl;
    cout << "Base的m_a是：" << s.Base::m_a << endl; // 添加作用域访问父类的数据
}

// 测试函数 2
void test02()
{
    son s1;
    s1.func(); // 调用 son 类的 func 函数
    s1.Base::func(); // 调用 Base 类的 func 函数
}

int main()
{
    test01(); // 测试成员变量
    test02(); // 测试成员函数
    return 0;
}
代码解析
1. Base 类
包含一个公有成员变量 m_a 和一个公有成员函数 func()。

2. son 类
继承自 Base 类。

重写了 m_a 和 func()，分别赋值为 200 和输出 "son成员函数已激活"。

3. test01 函数
测试 son 类和 Base 类的成员变量。

使用作用域运算符 :: 访问 Base 类的 m_a。

4. test02 函数
测试 son 类和 Base 类的成员函数。

使用作用域运算符 :: 访问 Base 类的 func()。

运行结果
复制
son的m_a是：200
Base的m_a是：100
son成员函数已激活
Base成员函数已激活
总结
修正了类定义缺少右花括号的问题。

将 son 类的定义移到 Base 类的外部。

取消注释 test01 函数，并添加了 test02 函数的测试。

希望这个解释能帮助你理解问题所在！如果还有疑问，欢迎继续提问！

给我一个能体现 菱形继承的例子代码
菱形继承（Diamond Inheritance）是 C++ 中多重继承的一个典型问题。它发生在以下情况：

一个类（派生类）继承自两个类（中间类），而这两个类又继承自同一个基类。

这会导致派生类中包含两份基类的成员，从而引发二义性问题。

为了解决菱形继承问题，C++ 引入了虚继承（virtual inheritance），确保派生类中只包含一份基类的成员。

以下是一个完整的代码示例，展示菱形继承的问题以及如何使用虚继承解决它。

代码示例
cpp
复制
#include <iostream>
using namespace std;

// 基类
class Animal
{
public:
    int age;

    Animal() : age(0) {}

    void eat()
    {
        cout << "Animal is eating." << endl;
    }
};

// 中间类 1
class Mammal : virtual public Animal // 使用虚继承
{
public:
    void breathe()
    {
        cout << "Mammal is breathing." << endl;
    }
};

// 中间类 2
class Bird : virtual public Animal // 使用虚继承
{
public:
    void fly()
    {
        cout << "Bird is flying." << endl;
    }
};

// 派生类
class Bat : public Mammal, public Bird
{
public:
    void displayAge()
    {
        cout << "Bat's age: " << age << endl; // 直接访问基类的成员
    }
};

int main()
{
    Bat bat;

    // 访问基类的成员
    bat.age = 5; // 没有二义性
    bat.displayAge();

    // 调用基类的成员函数
    bat.eat();

    // 调用中间类的成员函数
    bat.breathe();
    bat.fly();

    return 0;
}
